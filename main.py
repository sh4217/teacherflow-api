from audio_utils import validate_audio_file, get_audio_duration, process_audio_files
from fastapi import FastAPI, HTTPException, UploadFile, File, Form, Body
from fastapi.middleware.cors import CORSMiddleware
from uuid import uuid4
from typing import List
from pathlib import Path
from manim import *
import tempfile
import shutil
from fastapi.staticfiles import StaticFiles
from contextlib import asynccontextmanager
from manim_utils import SceneSegment, CombinedScript

print("=== DEBUG: Entering main.py file ===")

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("=== DEBUG: FastAPI startup event triggered ===")
    yield
    print("=== DEBUG: FastAPI shutdown event triggered ===")

app = FastAPI(lifespan=lifespan)

print("=== DEBUG: Configuring CORS middleware ===")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://teacherflow.ai", "https://www.teacherflow.ai"],
    allow_credentials=True,
    allow_methods=["POST", "GET", "DELETE", "OPTIONS"],
    allow_headers=["Content-Type"],
)

VIDEOS_DIR = Path("videos")
print(f"=== DEBUG: VIDEOS_DIR is set to: {VIDEOS_DIR.resolve()} ===")
VIDEOS_DIR.mkdir(exist_ok=True)

print("=== DEBUG: Mounting /videos static files ===")
app.mount("/videos", StaticFiles(directory="videos"), name="videos")

print("=== DEBUG: Defining health-check endpoint ===")

@app.get("/health")
async def health_check():
    print("=== DEBUG: /health endpoint was hit ===")
    return {"status": "healthy"}

print("=== DEBUG: Defining /generate-video endpoint ===")

async def validate_request(texts: List[str], audio_files: List[UploadFile]):
    """Validate the incoming request data"""
    if len(texts) != len(audio_files):
        print("=== DEBUG: Mismatched number of texts and audio files ===")
        raise HTTPException(status_code=400, detail="Number of texts must match number of audio files")

def create_scene_segments(texts: List[str], audio_paths: List[str]) -> List[SceneSegment]:
    """Create scene segments from texts and audio paths"""
    return [
        SceneSegment(text, audio_path)
        for text, audio_path in zip(texts, audio_paths)
    ]

async def render_video(segments: List[SceneSegment], video_path: Path) -> None:
    """Render the video using Manim and copy to final destination"""
    with tempfile.TemporaryDirectory() as temp_dir:
        config.media_dir = temp_dir
        config.quality = "medium_quality"
        config.output_file = "animation"
        
        print("=== DEBUG: Rendering Manim scene ===")
        scene = CombinedScript(segments)
        scene.render()
        
        generated_video = Path(temp_dir) / "videos" / "720p30" / "animation.mp4"
        if not generated_video.exists():
            print("=== ERROR: Video file not generated by Manim ===")
            raise Exception("Video file not generated")
        
        # Copy the file while we're still in the context
        shutil.copy(generated_video, video_path)
        print(f"=== DEBUG: Copied generated video to final path {video_path} ===")

def cleanup_temp_files(temp_files: List[str]):
    """Clean up temporary files"""
    for temp_file in temp_files:
        try:
            Path(temp_file).unlink()
        except Exception:
            pass

@app.post("/generate-video")
async def generate_video(
    texts: List[str] = Form(...),
    audio_files: List[UploadFile] = File(...)
):
    print("=== DEBUG: /generate-video endpoint called ===")
    temp_files = []
    
    try:
        # Validate request
        await validate_request(texts, audio_files)
        
        # Ensure videos directory exists
        VIDEOS_DIR.mkdir(parents=True, exist_ok=True)
        
        # Generate unique filename
        video_filename = f"{uuid4()}.mp4"
        video_path = VIDEOS_DIR / video_filename
        print(f"=== DEBUG: Generated video filename: {video_filename} ===")
        
        # Process audio files
        audio_paths, temp_files = await process_audio_files(audio_files)
        
        # Create scene segments
        segments = create_scene_segments(texts, audio_paths)
        
        # Render video and copy to destination
        await render_video(segments, video_path)
        
        return {"videoUrl": video_filename}
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"=== ERROR: Exception in /generate-video: {e}")
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cleanup_temp_files(temp_files)

@app.api_route("/delete/videos", methods=["POST", "DELETE"])
async def delete_videos(filenames: List[str] = Body(...)):
    print(f"=== DEBUG: Bulk delete request for {len(filenames)} videos ===")
    
    results = []
    for filename in filenames:
        if "/" in filename or "\\" in filename:
            print(f"=== DEBUG: Skipping invalid filename: {filename} ===")
            results.append({"filename": filename, "status": "error", "message": "Invalid filename"})
            continue
            
        video_path = VIDEOS_DIR / filename
        try:
            if not video_path.exists():
                print(f"=== DEBUG: Video file not found: {video_path} ===")
                results.append({"filename": filename, "status": "error", "message": "File not found"})
                continue
                
            video_path.unlink()
            print(f"=== DEBUG: Successfully deleted video: {video_path} ===")
            results.append({"filename": filename, "status": "success", "message": "Deleted"})
            
        except Exception as e:
            print(f"=== ERROR: Failed to delete video {filename}: {e} ===")
            results.append({"filename": filename, "status": "error", "message": str(e)})
    
    return {"results": results}

print("=== DEBUG: Finished loading main.py ===")
