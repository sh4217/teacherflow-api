from typing import List, Optional
from manim import *
from audio.audio_utils import get_audio_duration
from pathlib import Path
import tempfile
import shutil
# from ai_utils import fetch_manim_construct_snippet

_original_construct_snippet = '''"""Construct the scene with all segments."""
frame_height = config.frame_height

for i, segment in enumerate(self.segments):
    self.remove(*self.mobjects)
    text = self.create_text(segment.text, self.INITIAL_FONT_SIZE)
    while text.height > frame_height * 0.85 and text.font_size > self.MIN_FONT_SIZE:
        new_size = max(self.MIN_FONT_SIZE, text.font_size * 0.95)
        text = self.create_text(segment.text, new_size)
    text.move_to(ORIGIN)
    self.add(text)
    
    if segment.has_audio:
        try:
            self.add_sound(segment.audio_path)
            self.wait(segment.duration)
        except Exception as e:
            print(f"Audio playback failed for scene {i}: {e}")
            self.wait(5)
    else:
        self.wait(5)
    
    if i < len(self.segments) - 1:
        self.wait(0.25)
'''

class SceneSegment:
    def __init__(self, text: str, audio_path: Optional[str] = None):
        """Initialize a scene segment with text and optional audio.
        
        Args:
            text (str): The text to display in the scene
            audio_path (Optional[str]): Path to the audio file for this segment
        """
        self.text = text
        self.audio_path = audio_path
        self.has_audio = audio_path is not None
        self.duration = get_audio_duration(audio_path) if audio_path else 5.0

class CombinedScript(Scene):
    def __init__(self, segments: List[SceneSegment]):
        """Initialize the combined script scene.
        
        Args:
            segments (List[SceneSegment]): List of scene segments to render
        """
        super().__init__()
        self.segments = segments
        self.MIN_FONT_SIZE = 40
        self.INITIAL_FONT_SIZE = 72

    def create_text(self, content: str, font_size: float) -> MarkupText:
        """Create a text object with the given content and font size.
        
        Args:
            content (str): The text content to display
            font_size (float): Initial font size
            
        Returns:
            MarkupText: The configured text object
        """
        return MarkupText(
            content,
            line_spacing=1.2,
            font_size=font_size,
            width=config.frame_width * 0.8
        )

    def construct(self):
        """
        Dynamically fetch and execute the Manim construct snippet from OpenAI;
        if the snippet is empty or invalid, fall back to the original snippet.
        """
        # snippet_code = fetch_manim_construct_snippet()

        # # If the snippet is empty or malformed, use the fallback
        # if not snippet_code.strip():
        #     snippet_code = _original_construct_snippet

        # temporarily fall back to hardcoding the Manim logic
        # after testing Websocket works in prod, will debug LLM call
        snippet_code = _original_construct_snippet


        local_dict = {
            "self": self,
            "config": config,
            "ORIGIN": ORIGIN,
            "Exception": Exception,
            "print": print,
            "enumerate": enumerate,
            "max": max,
            "range": range,
        }

        exec(snippet_code, {}, local_dict)

def create_scene_segments(texts: List[str], audio_paths: List[str]) -> List[SceneSegment]:
    """Create scene segments from texts and audio paths"""
    return [
        SceneSegment(text, audio_path)
        for text, audio_path in zip(texts, audio_paths)
    ]

async def render_video(segments: List[SceneSegment], video_path: Path) -> None:
    """Render the video using Manim and copy to final destination"""
    with tempfile.TemporaryDirectory() as temp_dir:
        config.media_dir = temp_dir
        config.quality = "medium_quality"
        config.output_file = "animation"
        
        scene = CombinedScript(segments)
        scene.render()
        
        generated_video = Path(temp_dir) / "videos" / "720p30" / "animation.mp4"
        if not generated_video.exists():
            print("=== ERROR: Video file not generated by Manim ===")
            raise Exception("Video file not generated")
        
        shutil.copy(generated_video, video_path)
